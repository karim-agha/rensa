use {
  super::{validator::Validator, vote::Vote, Block, BlockData},
  crate::{
    primitives::{Account, Pubkey, ToBase58String},
    vm::{State, StateDiff},
  },
  chrono::{DateTime, Utc},
  ed25519_dalek::Signature,
  multihash::{
    Code as MultihashCode,
    Hasher,
    Multihash,
    MultihashDigest,
    Sha3_256,
  },
  serde::{Deserialize, Serialize},
  std::{
    collections::BTreeMap,
    fmt::Debug,
    io::{Error as StdIoError, ErrorKind},
    marker::PhantomData,
    time::Duration,
  },
};

/// Configures blockchain set limits across all validators.
///
/// Those limits ensure that a malicious contract would be able
/// to halt validators during execution or DoS them. They keep all
/// resources usage within a transaction bounded to limits defined
/// in genesis.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Limits {
  /// The maximum age in epochs of a finalized block that can be
  /// used as a justification of a vote on a block. This value should
  /// be chosen in proportion to epoch slots and block time. If its too
  /// short then block propagation delays might invalidate votes, if it
  /// is too long, then it allows for long-range attacks and has higher
  /// memory footprint.
  pub max_justification_age: u64,

  /// The minimum amount a validator has to stake to have its blocks
  /// accepted by the consensus. When a validator is offline for long
  /// enough, the penalties will start eating up its stake up to point
  /// where it drops below this level and then is excluded from
  /// consensus.
  pub minimum_stake: u64,

  /// The maximum number of accounts references a transaction accepts.
  /// This also means that this is the maximum number of distinct accounts
  /// a single transaction can interact with.
  pub max_input_accounts: usize,

  /// The maximum size in bytes a single account could allocate for its data.
  /// This data is allocated by contracts, if an account needs more data, it
  /// can employ various techniques to split the state into multiple accounts.
  pub max_account_size: usize,

  /// Maximum size of a single log entry in a transaction.
  /// This size applies to the sum of the key length and the value length,
  /// their combined length should be less than this number of bytes.
  pub max_log_size: usize,

  /// The maximum number of individual logs generated by a single transaction.
  pub max_logs_count: usize,

  /// The maximum number of transactions within one block.
  pub max_block_transactions: usize,

  /// In bytes, the maximum size of the compiled WASM of a smart contract.
  pub max_contract_size: usize,

  /// Maximum size of a block or any other single transmission
  /// over p2p gossip network in bytes.
  pub max_block_size: usize,
}

/// The genesis block of the blockchain.
///
/// Defines the very first block of a chain with a fixed
/// set of validators and a few other settings.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(
  bound = "D: Serialize, D: Eq, for<'a> D: Deserialize<'a>",
  rename_all = "camelCase"
)]
pub struct Genesis<D: BlockData> {
  /// The globally unique string that identifies this chain
  /// on the global network. This value is used to allow many
  /// instances of this validator software to be deployed as
  /// completely independent blockchains.
  pub chain_id: String,

  /// The timepoint int UTC timestamp which specifies when
  /// the blockchain is due to start. At this time validators
  /// are supposed to come online and start participating in the
  /// consensus process. Slots and epochs times are calculated
  /// from this timepoint.
  pub genesis_time: DateTime<Utc>,

  /// Thr length of a single slot during which there is one
  /// leader validator that proposes new blocks. Regardless if
  /// the leader produces a new block during this slot or not,
  /// the consensus will advance to the next leader validator
  /// when the slot time elapses.
  #[serde(with = "humantime_serde")]
  pub slot_interval: Duration,

  /// How many blocks make up one epoch. Epochs are groups of
  /// consecutive slots. Two epochs in a row that receive 2/3
  /// of validator votes constitute a finalized chechpoint that
  /// will never be reverted by any fork choice rule and could
  /// be considered forever immutable.
  pub epoch_blocks: u64,

  /// The hard limits on execution and other resource-consuming
  /// operations that must be respected by all validators on this
  /// chain.
  pub limits: Limits,

  /// The set of enabled builtin contracts.
  /// Builtins are special contracts implemented by the VM in
  /// native code. They are there for handling some computationally
  /// heavy operations like hashing or signature verification.
  ///
  /// The genesis block can enable those contracts by listing
  /// their pubkeys. See the [`vm/builtin`] module for more info.
  pub builtins: Vec<Pubkey>,

  /// The set of validators participating in the consensus along
  /// with their attributed stakes. Validators are always sorted
  /// so that the order of their appearance in the genesis file
  /// does not change the hash of the genesis.
  pub validators: Vec<Validator>,

  /// The currency used for staking rewards and transaction fees.
  /// This must also have a corresponding entry in the state dictionry
  /// in genesis that defines the coin mint for the same address.
  pub system_coin: Pubkey,

  /// The initial accounts state of the chain at the very first block.
  /// This is a list of accounts along with their balances, owners and
  /// data. This is the very first finalized state in the chain before
  /// any produced block gets finalized.
  pub state: BTreeMap<Pubkey, Account>,

  /// Block data stored in the first block.
  ///
  /// This is specific to the execution layer that is responsible
  /// for executing blocks and building state.
  #[serde(skip)]
  pub _marker: PhantomData<D>,
}

impl<D: BlockData> Block<D> for Genesis<D> {
  /// The hash of the genesis is used to determine a
  /// unique fingerprint of a blockchain configuration.
  fn hash(&self) -> Result<Multihash, StdIoError> {
    let mut sha3 = Sha3_256::default();
    sha3.update(self.chain_id.as_bytes());
    sha3.update(&self.genesis_time.timestamp_millis().to_le_bytes());
    sha3.update(&self.slot_interval.as_millis().to_le_bytes());
    sha3.update(&self.epoch_blocks.to_le_bytes());

    sha3.update(&self.limits.max_block_size.to_le_bytes());
    sha3.update(&self.limits.max_justification_age.to_le_bytes());
    sha3.update(&self.limits.minimum_stake.to_le_bytes());
    sha3.update(&self.limits.max_log_size.to_le_bytes());
    sha3.update(&self.limits.max_logs_count.to_le_bytes());
    sha3.update(&self.limits.max_account_size.to_le_bytes());
    sha3.update(&self.limits.max_input_accounts.to_le_bytes());
    sha3.update(&self.limits.max_block_transactions.to_le_bytes());
    sha3.update(&self.limits.max_contract_size.to_le_bytes());

    for builtin in &self.builtins {
      sha3.update(builtin);
    }

    for validator in &self.validators {
      sha3.update(&validator.pubkey);
      sha3.update(&validator.stake.to_le_bytes());
    }

    for (addr, acc) in &self.state {
      sha3.update(addr);
      match &acc.owner {
        Some(o) => sha3.update(o),
        None => sha3.update(&[0]),
      };

      match &acc.data {
        Some(v) => sha3.update(v),
        None => sha3.update(&[0]),
      }
    }

    MultihashCode::Sha3_256
      .wrap(sha3.finalize())
      .map_err(|e| std::io::Error::new(ErrorKind::Other, e))
  }

  /// Hash of the initial state configured in Genesis.
  fn state_hash(&self) -> Multihash {
    let mut state = StateDiff::default();
    for (k, v) in &self.state {
      state.set(*k, v.clone()).unwrap();
    }
    state.hash()
  }

  /// Always errors because this is the very first
  /// block of a block chain and its structure is
  /// special and different than other blocks produced
  /// by block proposers through the lifetime of the chain.
  fn parent(&self) -> Result<Multihash, StdIoError> {
    Err(StdIoError::new(
      ErrorKind::NotFound,
      "The genesis block has no parent",
    ))
  }

  /// The genesis block has no producer and thus nobody
  /// signed that block, as it comes from a config file
  /// rather than a validator.
  fn signature(&self) -> Option<&(Pubkey, Signature)> {
    None
  }

  /// Constant zero
  fn height(&self) -> u64 {
    0
  }

  /// The initial set of data stored in the genesis.
  /// This data is specific to the execution layer
  /// that drives the chain
  fn payload(&self) -> &D {
    panic!("genesis block has no payload!");
  }

  /// The gensis block has no votes because it is a
  /// constant parameter to the validator during the
  /// process startup.
  fn votes(&self) -> &[Vote] {
    &[]
  }
}

impl<D: BlockData> std::fmt::Display for Genesis<D> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let hash = self.hash().map_err(|_| std::fmt::Error)?;
    write!(f, "Genesis([{} @ {}])", hash.to_b58(), self.height())
  }
}
